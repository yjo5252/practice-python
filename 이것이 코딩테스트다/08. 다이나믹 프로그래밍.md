## 08. 다이나믹 프로그래밍


문제, 풀이방법, python 문법/자료구조, 코드


- 단순한 <재귀함수>로 비효율적인 프로그램을 작성한다 (<탑 다운>)
    - 그리고, 작은 문제에서 구한 답이 큰 문제에서 그대로 사용될 수 있으면 = 메모리제이션을 적용할 수 있으면 코드를 개선한다.
    - 단, 시스템상 재귀함수의 스택 크기가 한정되어 있을 수 있다.
    - recursion depth 오류 발생 가능
        - 이 경우, sys library의 setrecursionlimit() 함수를 호출해서 재귀 제한을 완화한다.
- 보텀업 방식


#### 8-2. 1로 만들기 
* 입력한 정수 X을 연한하는 횟수의 최솟값을 구한다. (연산 = 5, 3, 2,로 나누고 1을 뺀다)
* 입력 예제 : 26, 출력 결과: 3
* 풀이방법: 
  * dp 테이블을 초기화한다.
  * 점화식 끝에 1을 더해주는 이유는 함수의 호출 횟수를 구해야 하기 때문이다. 
  * 

```python
x = int(input())

d = [0] * 30001

for i in range(2, x+1):
    d[i] = d[i-1] + 1
    if i % 2 == 0:
        d[i] = min(d[i], d[i // 2] + 1)
    if i % 3 == 0:
        d[i] = min(d[i], d[i // 3] + 1)
    if i % 5 == 0:
        d[i] = min(d[i], d[i // 5] + 1)

print(d[x])
```

#### 8-3. 개미 전사 
* 풀이 방법
    * 그림으로 도식화한다
    * i-1번째 식량을 털기로 했음 현재 식량창고 털 수 없다. 
    * i-2번째 식량을 털기로 했음 현재 식량창고 털 수 있다. 
* 입력 예제 
```
4
1 3 1 5
```
* 출력 결과: 8
```python
n = int(input())

array = list(map(int, input().split()))

d = [0] * 100

d[0] = array[0]
d[1] = max(array[0], array[1])
for i in range(2,n):
    d[i] = max(d[i-1], d[i-2]+array[i])

print(d[n-1])
```

#### 8-4. 바닥 공사 
* 요구사항: 2xN 크기의 바닥을 채우는 방법의 수를 796,796으로 나눈 나머지를 출력한다. 
* 풀이방법: 


```python
n = int(input())

d = [0] * 1001

d[1] = 1
d[2] = 3
for i in range(3,n+1):
    d[i] = (d[i - 1] + 2*d[i - 2]) % 796796

print(d[n])
```
    
    
